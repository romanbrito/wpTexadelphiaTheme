{"version":3,"sources":["serviceWorker.js","components/Map.js","utilities/constants.js","utilities/utilities.js","components/Locations.js","components/Main.js","components/App.js","index.js"],"names":["Boolean","window","location","hostname","match","MapContainer","styled","div","_templateObject","MapElement","_templateObject2","LocContainer","_templateObject3","MapComponent","compose","withProps","googleMapURL","loadingElement","containerElement","react_default","a","createElement","mapElement","withHandlers","lifecycle","componentWillMount","data","this","props","setState","zoomToMarkers","map","bounds","google","maps","LatLngBounds","i","length","loc","LatLng","coordinates","extend","fitBounds","withScriptjs","withGoogleMap","lib","ref","defaultZoom","defaultCenter","lat","lng","MarkerClusterer","onClick","onMarkerClustererClick","averageCenter","enableRetinaIcons","gridSize","marker","key","label","position","e","open","address","city","state","zip","Map","_ref","LocationsContainer","Locations_templateObject","Locations","_this2","fetch","method","then","response","json","components_Map","locations","Component","Main","Switch","Route","exact","path","component","App","BrowserRouter","components_Main","ReactDOM","render","components_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c308c4a3.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\r\nimport styled from 'styled-components';\r\nimport {compose, withProps, lifecycle, withHandlers} from 'recompose';\r\nimport {withScriptjs, withGoogleMap, GoogleMap, Marker} from 'react-google-maps';\r\nimport {MarkerClusterer} from 'react-google-maps/lib/components/addons/MarkerClusterer';\r\nimport {googleMapURL} from '../utilities/constants';\r\nimport {destination} from '../utilities/utilities';\r\n\r\nconst MapContainer = styled.div`\r\n  height: 100%;\r\n  width: 100%;\r\n`;\r\n\r\nconst MapElement = styled.div`\r\n  height: 100%;\r\n  `;\r\n\r\nconst LocContainer = styled.div`\r\n  width: 100vw;\r\n  height: 100vh;\r\n  \r\n  @media (min-width: 455px) {\r\n    width: 50vw;\r\n    height: 50vh;\r\n  }\r\n`;\r\n\r\nconst MapComponent = compose(\r\n  withProps({\r\n    googleMapURL,\r\n    loadingElement: 'Loading...',\r\n    containerElement: <MapContainer/>,\r\n    mapElement: <MapElement/>\r\n  }),\r\n  withHandlers({}),\r\n  lifecycle({\r\n    componentWillMount() {\r\n      const {data} = this.props;\r\n\r\n      this.setState({\r\n        zoomToMarkers: map => {\r\n          const bounds = new window.google.maps.LatLngBounds();\r\n\r\n          for (let i = 0; i < data.length; i++) {\r\n            const loc = new window.google.maps.LatLng(data[i].coordinates);\r\n            bounds.extend(loc);\r\n          }\r\n\r\n          map.fitBounds(bounds);\r\n        },\r\n\r\n      })\r\n    }\r\n  }),\r\n  withScriptjs,\r\n  withGoogleMap\r\n)(\r\n  props => {\r\n\r\n    return (\r\n      <section>\r\n        <GoogleMap\r\n          ref={props.zoomToMarkers}\r\n          defaultZoom={8}\r\n          defaultCenter={{lat: 29.7368233, lng: -95.513883}}>\r\n          <MarkerClusterer\r\n            onClick={props.onMarkerClustererClick}\r\n            averageCenter\r\n            enableRetinaIcons\r\n            gridSize={15}>\r\n            {props.data.map(marker => (\r\n              <Marker\r\n                key={marker.label}\r\n                position={marker.coordinates}\r\n                label={marker.label}\r\n                onClick={e => window.open(destination(marker.address, marker.city, marker.state, marker.zip))}\r\n              />\r\n            ))}\r\n          </MarkerClusterer>\r\n        </GoogleMap>\r\n      </section>\r\n    )\r\n  }\r\n);\r\n\r\nconst Map = ({data}) => {\r\n\r\n  return (\r\n    <LocContainer>\r\n      <MapComponent data={data}/>\r\n    </LocContainer>\r\n  )\r\n};\r\n\r\nexport default Map;","// const APIkeyProduction = 'AIzaSyBZAdtCTX8ZlyU39tML3S_dOmmWWAh6cdk'\r\n// remove the following key when ftp\r\nconst APIkeyDevelop = 'AIzaSyDP1umTdbqfnYTGbUuaWtqBdcTE0TcDeHY';\r\n\r\nexport const googleMapURL = 'https://maps.googleapis.com/maps/api/js?key=' + APIkeyDevelop + '&v=3.exp&libraries=geometry,drawing,places';","// returns an object from an array of objects\r\nexport const arrayToObject = (array) => {\r\n\r\n  return array.reduce((obj, item) => {\r\n    obj[item.id] = item;\r\n    return obj;\r\n  }, {})\r\n\r\n};\r\n\r\nexport const destination = (address, city, state, zip) => {\r\n  const googleMapsDestination = 'https://www.google.com/maps/dir/?api=1&destination=texadelphia,' + address + ',' + city + ',' + state + ' ' + zip;\r\n  const googleMapsDestinationGalveston = 'https://www.google.com/maps/dir/?api=1&destination=' + address + ',' + city + ',' + state + ' ' + zip;\r\n\r\n  if (city === 'Galveston') {\r\n    return googleMapsDestinationGalveston;\r\n  } else {\r\n    return googleMapsDestination;\r\n  }\r\n\r\n};\r\n\r\n// distance Matrix\r\n// function to transform to radians\r\nconst Radians = degree => {\r\n  return degree * Math.PI /180;\r\n};\r\n\r\n// distance between two coordinates\r\nclass LatLng {\r\n  constructor(lat, lng) {\r\n    this.lat = Number(lat);\r\n    this.lng = Number(lng);\r\n  }\r\n\r\n  distanceTo(point) {\r\n    if (!(point instanceof LatLng)) throw new TypeError ('not a LatLon object');\r\n\r\n    const radius = 6371e3;\r\n    const PHI1 = Radians(this.lat);\r\n    const LAMBDA1 = Radians(this.lng);\r\n    const PHI2 = Radians(point.lat);\r\n    const LAMBDA2 = Radians(point.lng);\r\n    const DeltaPhi = PHI2 - PHI1;\r\n    const DeltaLambda = LAMBDA2 - LAMBDA1;\r\n    const a = Math.sin(DeltaPhi/2) * Math.sin(DeltaPhi/2) + Math.cos(PHI1) * Math.cos(PHI2) * Math.sin(DeltaLambda/2) * Math.sin(DeltaLambda/2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\r\n    // return distance in meters\r\n    return radius * c;\r\n  }\r\n\r\n}\r\n\r\n// origin {lat: 333, lng: 333} destination [{lat: 111, lng: 222}, {lat: 333, lng: 444}...]\r\nexport const distanceMatrix = (origin, destinationMatrix) => {\r\n  const o = new LatLng(origin.lat, origin.lng);\r\n\r\n  // return distance array\r\n  return destinationMatrix.map(destination => {\r\n    const d = new LatLng(destination.lat, destination.lng);\r\n    return o.distanceTo(d);\r\n  })\r\n\r\n};","import React, {Component} from 'react';\r\nimport styled from 'styled-components';\r\nimport Map from './Map';\r\n\r\nconst LocationsContainer = styled.div`\r\n  width: 100%;\r\n  height: 100%;\r\n`;\r\nconst JSON_URL = 'https://www.texadelphia.com/wp-content/themes/texsite/json/locations.json';\r\n\r\nclass Locations extends Component{\r\n\r\n  state = {\r\n    data: null\r\n  };\r\n\r\n  componentWillMount() {\r\n    fetch(JSON_URL, {method: 'GET'})\r\n      .then(response => response.json())\r\n      .then(data => this.setState({data}))\r\n  }\r\n\r\n  render() {\r\n\r\n    const {data} = this.state;\r\n\r\n    return (\r\n      <LocationsContainer>\r\n        {data ? <Map data={data.locations}/> :\r\n          <p>Loading locations</p>\r\n        }\r\n      </LocationsContainer>\r\n    );\r\n  }\r\n\r\n\r\n}\r\n\r\nexport default Locations;\r\n","import React from 'react';\r\nimport {Switch, Route} from 'react-router-dom';\r\nimport Locations from './Locations';\r\n\r\n\r\n\r\nconst Main = () => {\r\n  return (\r\n    <Switch>\r\n      <Route exact path=\"/\" component={Locations}/>\r\n    </Switch>\r\n  );\r\n};\r\n\r\nexport default Main;\r\n","import React, { Component } from 'react';\nimport {BrowserRouter} from 'react-router-dom';\nimport Main from './Main'\n\nclass App extends Component {\n  render() {\n    return (\n        <BrowserRouter>\n        <Main/>\n        </BrowserRouter>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport * as serviceWorker from './serviceWorker';\nimport './index.css';\nimport App from './components/App';\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}